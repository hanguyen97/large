legend.position = "top",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_line(color = "black"),
axis.line.y.right = element_blank(),
axis.line.x.top = element_blank()
)
# 850 x 556
# Plot them
crystal_dt <- copy(dt_full)
crystal_dt[, c("median", "IQR") := tstrsplit(expvar_Crystal, " \\(|\\)", type.convert = TRUE)]
ggplot(crystal_dt, aes(x = pop, y = median, color = Method, group = Method)) +
geom_line(linewidth = 1.2) +
geom_point(size = 2) +
scale_x_reverse() +
scale_color_brewer(palette = "Spectral") +
facet_wrap(~ par) +
labs(x = "Population Subsample (%)",
y = "Median Explained Variance (%)",
color = "Method",
title = "Crystal Cognition") +
theme_minimal(base_size = 18) +
coord_cartesian(ylim = c(0, 0.2)) +
theme(
strip.text = element_text(face = "bold", size = 20),
axis.title = element_text(size = 20),
axis.text = element_text(size = 16),
legend.title = element_text(size = 18),
legend.text = element_text(size = 16),
legend.position = "top",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_line(color = "black"),
axis.line.y.right = element_blank(),
axis.line.x.top = element_blank()
)
# 850 x 556
# Plot them
crystal_dt <- copy(dt_full)
crystal_dt[, c("median", "IQR") := tstrsplit(expvar_Fluid, " \\(|\\)", type.convert = TRUE)]
ggplot(crystal_dt, aes(x = pop, y = median, color = Method, group = Method)) +
geom_line(linewidth = 1.2) +
geom_point(size = 2) +
scale_x_reverse() +
scale_color_brewer(palette = "Spectral") +
facet_wrap(~ par) +
labs(x = "Population Subsample (%)",
y = "Median Explained Variance (%)",
color = "Method",
title = "Fluid Cognition") +
theme_minimal(base_size = 18) +
coord_cartesian(ylim = c(0, 0.2)) +
theme(
strip.text = element_text(face = "bold", size = 20),
axis.title = element_text(size = 20),
axis.text = element_text(size = 16),
legend.title = element_text(size = 18),
legend.text = element_text(size = 16),
legend.position = "top",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_line(color = "black"),
axis.line.y.right = element_blank(),
axis.line.x.top = element_blank()
)
# 850 x 556
# Plot them
crystal_dt <- copy(dt_full)
crystal_dt[, c("median", "IQR") := tstrsplit(expvar_Crystal, " \\(|\\)", type.convert = TRUE)]
ggplot(crystal_dt, aes(x = pop, y = median, color = Method, group = Method)) +
geom_line(linewidth = 1.2) +
geom_point(size = 2) +
scale_x_reverse() +
scale_color_brewer(palette = "Spectral") +
facet_wrap(~ par) +
labs(x = "Population Subsample (%)",
y = "Median Explained Variance (%)",
color = "Method",
title = "Crystal Cognition") +
theme_minimal(base_size = 18) +
coord_cartesian(ylim = c(0, 0.2)) +
theme(
strip.text = element_text(face = "bold", size = 20),
axis.title = element_text(size = 20),
axis.text = element_text(size = 16),
legend.title = element_text(size = 18),
legend.text = element_text(size = 16),
legend.position = "top",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.line = element_line(color = "black"),
axis.line.y.right = element_blank(),
axis.line.x.top = element_blank()
)
# 850 x 556
((4+3+2+1)+(3+2+1)+(2+1)+1)/6^3
5/54
(1/2)/(0.5 + 0.5^6)
1 - (1/3)^3
a = 1 - (1/3)^3
(a * 0.25) / (a*0.25 + (1-a)*0.75)
8/11
a1 = 1/36
a6 = 1/36
a2 = 2*(1/6)*(2/6)
a2
a3 = 2*(1/6)*(3/6)
a4 = 2*(1/6)*(4/6)
a5 = 2*(1/6)*(5/6)
a1 + a2 + a3 + a4+ a5+a6
a2 = 2*(1/6)*(1/6) + (1/36)
a2
a3
a3 = 2*(1/6)*(2/6) + (1/36)
a3
a4 = 2*(1/6)*(3/6) + (1/36)
a5 = 2*(1/6)*(4/6) + (1/36)
a6 = 2*(1/6)*(5/6) + (1/36)
a1 + a2 + a3 + a4 + a5
a1 + a2 + a3 + a4 + a5 + a6
1*a1 + 2*a2 + 3*a3 + 4*a4 + 5*a5 + 6*a6
161/36
1/2.5
1/0.025
1 - (1/100 + 98*((1/100)*(1/97)))
(2^5)/(1+2^5)
2^5
1 - 2*0.4*0.6
0.36/0.52
2/3 + 4/9*(2+3)
2.888889*3/2
1/0.025
ph = 550/1000
p = 1/2
(ph-p)/(sqrt(p(1-p))/1000)
(ph-p)/(sqrt(p*(1-p))/1000)
(ph-p)/(sqrt(p*(1-p))/1000)
(ph-p)/(sqrt(p*(1-p)/1000))
797.63 - 52.13
64.5 + 204.43+100
86+75.73
64.5+21.86
368.93+161.73+86.36+180.61
a = (1000-980)/1000
a
b = (2000-1950)/2000
b
(1/3)*a / ((1/3)*a + (2/3)*b)
60*.8
60 - 48
.1*40
40-4
46/12
26/3
46/3
46/4
46/2
1/3*((4 - 1)^2 + (1-2)^2 + (5/2-1)^2)
36/10
25/12
10/5
49/12
50*40*4
8*12
60*40*4
9600*12
?glmnet
library(glmnet)
?glmnet
load("~/Downloads/block0.01_p300_n500_diag0_R50_data.RData")
View(X_list)
View(Theta_list)
load("~/Downloads/block0.01_p300_n500_diag0_R50_compare.arr.RData")
View(compare.arr)
View(X_list)
library(huge)
?huge.generator
100 / 3 / 5
94/100 * 50
98/100 * 50
load("~/Documents/Cornell/Projects/FC_SC/Code/Results/Data/Elvisha_100206_TS.RData")
fname("Elvisha_100206_TS")
id <- "100206"
# Load libraries
library(ATTglasso)
library(stringr)
library(corrplot)
library(CVglasso)
library(glasso)
library(huge)
library(parallel)
library(reshape2)
library(ggplot2)
library(PCGLASSO)
fname <- "Elvisha_100206_TS"
id <- "100206"
idx <- 1:1200
X1 <- timeseries[idx, regions]
regions <- 1:86
X1 <- timeseries[idx, regions]
var(X1)
X1 <- timeseries[idx, regions]
X2 <- timeseries[idx + 1200, regions]
X3 <- timeseries[idx + 2400, regions]
X4 <- timeseries[idx + 3600, regions]
pen <- TRUE
# ATTglasso
Theta.hat.att.glasso1 <- glasso_autotune(X=X1, alpha=0.02, thr=0.05, maxit=20, penalize_diag=pen, verbose=TRUE)
Theta.hat.att.glasso2 <- glasso_autotune(X=X2, alpha=0.02, thr=0.05, maxit=20, penalize_diag=pen, verbose=TRUE)
Theta.hat.att.glasso3 <- glasso_autotune(X=X3, alpha=0.02, thr=0.05, maxit=20, penalize_diag=pen, verbose=TRUE)
Theta.hat.att.glasso4 <- glasso_autotune(X=X4, alpha=0.02, thr=0.05, maxit=20, penalize_diag=pen, verbose=TRUE)
out.att.glasso <- (Theta.hat.att.glasso1$Theta + Theta.hat.att.glasso2$Theta +
Theta.hat.att.glasso3$Theta + Theta.hat.att.glasso4$Theta) / 4
plot_corr <- function(df, method) {
# set diagonal values to NA
df$value[df$Var1 == df$Var2] <- NA
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
# # base heatmap
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
mid = "white", midpoint = 0,
na.value = "white",
limits = c(-1, 1)) +
coord_equal() +
theme_minimal(base_size = 12) +
theme(axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 10),
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)) +
guides(fill = "none") +
labs(title = paste0(method, " (FC)  p = ", r, "  n = ", 1200))
}
ATT = out.att.glasso
df <- mat2df(prec2corr(ATT), "Autotune")
prec2corr <- function(Theta) {
D <- 1 / sqrt(diag(Theta))
P <- diag(D) %*% Theta %*% diag(D)  # correlation matrix
return(P)
}
mat2df <- function(M, method) {
df <- melt(M)
colnames(df) <- c("Var1", "Var2", "value")
df$Method <- method
df
}
plot_corr <- function(df, method) {
# set diagonal values to NA
df$value[df$Var1 == df$Var2] <- NA
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
# # base heatmap
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
mid = "white", midpoint = 0,
na.value = "white",
limits = c(-1, 1)) +
coord_equal() +
theme_minimal(base_size = 12) +
theme(axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 10),
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)) +
guides(fill = "none") +
labs(title = paste0(method, " (FC)  p = ", r, "  n = ", 1200))
}
df <- mat2df(prec2corr(ATT), "Autotune")
p1 <- plot_corr(df, "LARGE")
df
p1 <- plot_corr(df, "Autotune")
df <- mat2df(prec2corr(ATT), "Autotune")
# set diagonal values to NA
df$value[df$Var1 == df$Var2] <- NA
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
# # base heatmap
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
mid = "white", midpoint = 0,
na.value = "white",
limits = c(-1, 1)) +
coord_equal() +
theme_minimal(base_size = 12) +
theme(axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 10),
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)) +
guides(fill = "none") +
labs(title = paste0(method, " (FC)  p = ", r, "  n = ", 1200))
method="LARGE"
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
# # base heatmap
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
mid = "white", midpoint = 0,
na.value = "white",
limits = c(-1, 1)) +
coord_equal() +
theme_minimal(base_size = 12) +
theme(axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 10),
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)) +
guides(fill = "none") +
labs(title = paste0(method, " (FC)  p = ", r, "  n = ", 1200))
r = 86
ggplot(df, aes(x = Var1, y = Var2, fill = value)) +
# # base heatmap
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red",
mid = "white", midpoint = 0,
na.value = "white",
limits = c(-1, 1)) +
coord_equal() +
theme_minimal(base_size = 12) +
theme(axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.title = element_text(size = 10),
panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)) +
guides(fill = "none") +
labs(title = paste0(method, " (FC)  p = ", r, "  n = ", 1200))
Theta.hat.att.glasso1 <- glasso_autotune(X=X1, alpha=0.02, thr=0.0005, maxit=20, penalize_diag=pen, verbose=TRUE)
setwd("~/Documents/Cornell/Projects/FC_SC/Code/Rpack/large")
devtools::document()
devtools::build()
rm(list = ls())
setwd("~/Documents/Cornell/Projects/FC_SC/Code/Rpack/ATTglasso")
#---------- Load libraries ----------#
library(MASS)
library(corrplot)
#---------- Simulate data ----------#
set.seed(1)
p <- 20
n <- 100
choose(p,2)
data.name <- paste0("band1_p", p, "_n",n)
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:p]) <- offd1
diag(Theta[2:p, 1:(p-1)]) <- offd1
eigen(Theta)$values
Sigma <- solve(Theta)
diag(Sigma)
eigen(Sigma)$values
if (min(eigen(Sigma)$values)<=1e-3) {
stop("Sigma is not positive definite")
}
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
corrplot(cov2cor(Theta), method = "color", tl.pos="n")
n = nrow(X)
p = ncol(X)
library(large)
out <- fit_large(X = X, verbose=TRUE)
?fit_large
devtools::check()
devtools::document()
devtools::build()
#---------- Load libraries ----------#
library(MASS)
library(corrplot)
#---------- Simulate data ----------#
set.seed(1)
p <- 20
n <- 100
choose(p,2)
data.name <- paste0("band1_p", p, "_n",n)
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:p]) <- offd1
diag(Theta[2:p, 1:(p-1)]) <- offd1
eigen(Theta)$values
Sigma <- solve(Theta)
diag(Sigma)
eigen(Sigma)$values
if (min(eigen(Sigma)$values)<=1e-3) {
stop("Sigma is not positive definite")
}
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
corrplot(cov2cor(Theta), method = "color", tl.pos="n")
library(large)
out <- fit_large(X = X, verbose=TRUE)
corrplot(cov2cor(out$Theta), method = "color", tl.pos="n")
out$Theta
set.seed(1)
# Generate data from AR(1) model
p <- 10
n <- 200
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:(p)]) <- offd1
diag(Theta[2:(p), 1:(p-1)]) <- offd1
Sigma <- solve(Theta)
diag(Sigma)
library(MASS)
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
round(out$Theta,4)
knitr::opts_chunk$set(echo = TRUE)
library(large)
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
# Generate data from AR(1) model
p <- 10
n <- 200
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:(p)]) <- offd1
diag(Theta[2:(p), 1:(p-1)]) <- offd1
Sigma <- solve(Theta)
diag(Sigma)
library(MASS)
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
library(large)
start.T <- Sys.time()
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
(Sys.time()-start.T )
round(out$Theta,4)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
# Generate data from AR(1) model
p <- 10
n <- 200
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:(p)]) <- offd1
diag(Theta[2:(p), 1:(p-1)]) <- offd1
Sigma <- solve(Theta)
diag(Sigma)
library(MASS)
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
library(large)
start.T <- Sys.time()
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
(Sys.time()-start.T )
round(out$Theta,4)
cache = TRUE
unlink("cache", recursive = TRUE)
rm(list = ls())
rmarkdown::render("README.md", output_format = "github_document")
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
# Generate data from AR(1) model
p <- 10
n <- 200
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:(p)]) <- offd1
diag(Theta[2:(p), 1:(p-1)]) <- offd1
Sigma <- solve(Theta)
diag(Sigma)
library(MASS)
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
library(large)
start.T <- Sys.time()
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
(Sys.time()-start.T )
round(out$Theta,4)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
# Generate data from AR(1) model
p <- 10
n <- 200
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:(p)]) <- offd1
diag(Theta[2:(p), 1:(p-1)]) <- offd1
Sigma <- solve(Theta)
diag(Sigma)
library(MASS)
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
library(large)
start.T <- Sys.time()
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
(Sys.time()-start.T )
round(out$Theta,4)
knitr::opts_chunk$set(echo = TRUE)
# You can install the development version from GitHub:
# install.packages("devtools")
devtools::install_github("hanguyen97/large")
set.seed(1)
# Generate data from AR(1) model
p <- 10
n <- 200
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:(p)]) <- offd1
diag(Theta[2:(p), 1:(p-1)]) <- offd1
Sigma <- solve(Theta)
diag(Sigma)
library(MASS)
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
library(large)
start.T <- Sys.time()
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
(Sys.time()-start.T )
round(out$Theta,4)
library(large)
start.T <- Sys.time()
out <- fit_large(X=X, alpha=0.02, thr=1e-4)
(Sys.time()-start.T )
round(out$Theta,4)
